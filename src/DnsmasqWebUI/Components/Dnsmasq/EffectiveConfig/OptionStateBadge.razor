@namespace DnsmasqWebUI.Components.Dnsmasq.EffectiveConfig
@using DnsmasqWebUI.Models.Dnsmasq
@using DnsmasqWebUI.Models.Dnsmasq.EffectiveConfig

@if (Source?.IsReadOnly == true)
{
    @if (IsInteractive && Ui != null)
    {
        <button type="button" id="@AnchorId" class="badge bg-secondary ec-badge-inline border-0 ms-1" title="@(Source?.GetReadOnlyTooltip())"
                @onclick="OnReadonlyClick" @onmouseleave="OnReadonlyMouseLeave">
            readonly
        </button>
    }
    else
    {
        <span class="badge bg-secondary ec-badge-inline ms-1" title="@(Source?.GetReadOnlyTooltip())">readonly</span>
    }
}
else if (ShowEditableBadge)
{
    @if (EditableAsButton)
    {
        @if (IsActiveEditor)
        {
            <button type="button"
                    class="badge ec-badge-inline border-0 ms-1 bg-secondary"
                    @onmousedown:preventDefault
                    @onclick="OnCancelClick"
                    @onclick:stopPropagation="true"
                    title="Cancel and clear unsaved changes for this field"
                    aria-label="Cancel">
                cancel
            </button>
        }
        else
        {
            <button type="button"
                    class="badge ec-badge-inline border-0 ms-1 @(HasPendingChange ? "bg-warning text-dark" : "bg-primary")"
                    @onclick="OnEditableClick"
                    @onclick:stopPropagation="true"
                    title="@(HasPendingChange ? "Pending change" : "Edit this field")"
                    aria-label="Edit">
                @(HasPendingChange ? "pending" : "editable")
            </button>
        }
    }
    else
    {
        <span class="badge bg-primary ec-badge-inline ms-1">editable</span>
    }
}

@code {
    [Parameter] public string AnchorId { get; set; } = "";
    [Parameter] public ConfigValueSource? Source { get; set; }
    [Parameter] public string OptionName { get; set; } = "";
    [Parameter] public object? Value { get; set; }
    /// <summary>When true, render readonly as button and raise click/mouseleave via context.</summary>
    [Parameter] public bool IsInteractive { get; set; }
    /// <summary>When true, show editable/pending badge for non-readonly fields.</summary>
    [Parameter] public bool ShowEditableBadge { get; set; }
    /// <summary>When true, badge shows "pending" and warning style.</summary>
    [Parameter] public bool HasPendingChange { get; set; }
    /// <summary>When true, editable badge is a button; otherwise a static span.</summary>
    [Parameter] public bool EditableAsButton { get; set; } = true;
    /// <summary>When true, this field is the active editor; show Cancel instead of Edit and invoke OnCancelRequested on click.</summary>
    [Parameter] public bool IsActiveEditor { get; set; }
    /// <summary>When user clicks Cancel (while IsActiveEditor). Invoke before deactivating so parent can clear draft.</summary>
    [Parameter] public EventCallback OnCancelRequested { get; set; }
    /// <summary>Field key for activation via context when editable badge is clicked.</summary>
    [Parameter] public string? FieldKey { get; set; }
    [CascadingParameter] public EffectiveConfigUiContext? Ui { get; set; }

    private async Task OnCancelClick()
    {
        if (OnCancelRequested.HasDelegate)
            await OnCancelRequested.InvokeAsync();
        else if (Ui != null)
            await Ui.DeactivateFieldAsync();
    }

    private Task OnEditableClick()
    {
        if (Ui == null || string.IsNullOrEmpty(FieldKey)) return Task.CompletedTask;
        return Ui.ActivateFieldAsync(FieldKey);
    }

    private Task OnReadonlyClick()
    {
        if (Ui == null || Source == null) return Task.CompletedTask;
        return Ui.RequestReadonlyPopoverAsync(new ReadonlyBadgeClickedEventArgs(AnchorId, Source, OptionName, Value));
    }

    private Task OnReadonlyMouseLeave()
    {
        if (Ui == null) return Task.CompletedTask;
        return Ui.ScheduleReadonlyPopoverCloseAsync();
    }
}
