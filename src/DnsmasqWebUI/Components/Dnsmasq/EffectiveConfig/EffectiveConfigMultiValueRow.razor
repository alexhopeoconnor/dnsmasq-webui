@namespace DnsmasqWebUI.Components.Dnsmasq.EffectiveConfig
@using DnsmasqWebUI.Models.Dnsmasq
@using DnsmasqWebUI.Models.Dnsmasq.EffectiveConfig

<li class="ec-field">
    <span id="@OptionHelpAnchorId" class="ec-field-label @(OptionHelpKey != null ? "ec-field-label-help" : null)" title="@LabelTooltip" @onclick="RaiseOptionHelpRequested" @onmouseleave="RaiseLabelMouseLeave"><strong>@Label:</strong></span>
    @if (IsActiveEditor)
    {
        <span class="ec-field-value ec-field-value-multi" @onclick:stopPropagation="true">
            <textarea class="form-control form-control-sm" rows="@(Math.Max(2, (Items?.Count ?? 0) + 1))" @oninput="OnLinesInput" placeholder="One value per line">@_editLines</textarea>
        </span>
    }
    else
    {
        <span class="ec-field-value ec-field-value-multi">
            @if (Items?.Count > 0)
            {
                <ol class="ec-field-value-list">
                    @foreach (var (item, index) in Items!.Select((item, index) => (item, index)))
                    {
                        var anchorId = ReadonlyBadgeAnchorIdBase != null ? ReadonlyBadgeAnchorIdBase + "-" + index : null;
                        var args = new ReadonlyBadgeClickedEventArgs(anchorId ?? "", item.Source!, Label, item.Value);
                        <li><EffectiveConfigMultiValueItem Value="@item.Value" Source="@item.Source" IsEditMode="@IsEditMode" ReadonlyBadgeAnchorId="@anchorId" OnReadonlyBadgeClick="@(() => _ = OnReadonlyBadgeClicked.InvokeAsync(args))" OnReadonlyBadgeMouseLeave="@OnReadonlyBadgeMouseLeave" /></li>
                    }
                </ol>
            }
            else
            {
                <span class="text-muted">(none)</span>
            }
        </span>
    }
</li>

@code {
    [Parameter] public string Label { get; set; } = "";
    [Parameter] public IReadOnlyList<ValueWithSource>? Items { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<string>> ItemsChanged { get; set; }
    [Parameter] public string? LabelTooltip { get; set; }
    [Parameter] public string? OptionHelpKey { get; set; }
    [Parameter] public string? OptionHelpAnchorId { get; set; }
    [Parameter] public bool IsActiveEditor { get; set; }
    [Parameter] public bool IsEditMode { get; set; }
    [Parameter] public string? ReadonlyBadgeAnchorIdBase { get; set; }
    [Parameter] public EventCallback<ReadonlyBadgeClickedEventArgs> OnReadonlyBadgeClicked { get; set; }
    [Parameter] public EventCallback OnReadonlyBadgeMouseLeave { get; set; }
    [Parameter] public EventCallback<ConfigOptionHelpRequestEventArgs> OnOptionHelpRequested { get; set; }

    private string _editLines = "";

    private async Task RaiseOptionHelpRequested()
    {
        if (string.IsNullOrEmpty(OptionHelpKey) || string.IsNullOrEmpty(OptionHelpAnchorId)) return;
        await OnOptionHelpRequested.InvokeAsync(new ConfigOptionHelpRequestEventArgs { HelpKey = OptionHelpKey, OptionLabel = Label, AnchorId = OptionHelpAnchorId });
    }

    private async Task RaiseLabelMouseLeave()
    {
        if (string.IsNullOrEmpty(OptionHelpAnchorId)) return;
        await OnOptionHelpRequested.InvokeAsync(new ConfigOptionHelpRequestEventArgs { AnchorId = OptionHelpAnchorId, IsLabelMouseLeave = true });
    }

    protected override void OnParametersSet()
    {
        if (Items != null && Items.Count > 0)
            _editLines = string.Join("\n", Items.Select(i => i.Value));
        else
            _editLines = "";
    }

    private async Task OnLinesInput(ChangeEventArgs e)
    {
        var text = e.Value?.ToString() ?? "";
        _editLines = text;
        var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries).Select(l => l.Trim()).Where(l => l.Length > 0).ToList();
        await ItemsChanged.InvokeAsync(lines);
    }
}
