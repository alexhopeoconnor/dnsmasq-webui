@page "/"
@rendermode InteractiveServer
@namespace DnsmasqWebUI.Components.Pages
@inject IStatusClient StatusClient
@inject IConfigSetClient ConfigSetClient
@inject IReloadClient ReloadClient
@inject IClientSettingsService ClientSettingsService
@inject IOptions<ApplicationOptions> AppOptions
@implements IDisposable

<PageTitle>Dnsmasq | @AppTitle</PageTitle>

@if (_loading)
{
    <p class="text-muted"><em>Loading…</em></p>
}
else if (_error != null)
{
    <div class="alert alert-danger">@_error</div>
}
else if (_status != null)
{
    <section class="page-section">
        <h2 class="page-section-title">Service</h2>
        <div class="alert alert-@(_status.DnsmasqStatus == "active" ? "success" : "secondary") py-2 mb-2">
            <strong>Dnsmasq:</strong> @GetStatusLabel(_status)
            @if (_status.StatusCommandExitCode.HasValue)
            {
                <span class="ms-1 text-muted small">(exit @_status.StatusCommandExitCode.Value)</span>
            }
            @if (!string.IsNullOrEmpty(_status.StatusCommandStderr))
            {
                <span class="ms-1 text-muted small">— @_status.StatusCommandStderr</span>
            }
        </div>
        @if (_status.DnsmasqStatus != "active" && (_status.StatusCommandStdout != null || _status.StatusCommandStderr != null))
        {
            <pre class="pre-block mt-2 mb-0" style="max-height: 12rem;">@(_status.StatusCommandStdout != null ? _status.StatusCommandStdout : "")@(_status.StatusCommandStdout != null && _status.StatusCommandStderr != null ? "\n" : "")@(_status.StatusCommandStderr ?? "")</pre>
        }
        @if (_status.ReloadCommandConfigured)
        {
            <div class="d-flex align-items-center gap-2 flex-wrap">
                <button class="btn btn-primary btn-sm" @onclick="ReloadDnsmasq" disabled="@_reloading">
                    @if (_reloading)
                    {
                        <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                    }
                    @(_reloading ? "Reloading…" : "Reload config")
                </button>
                @if (!string.IsNullOrEmpty(_reloadMessage))
                {
                    <span class="@(_reloadSuccess ? "text-success" : "text-danger") small">@_reloadMessage</span>
                }
                @if (!_reloadSuccess && _reloadDetail != null)
                {
                    <pre class="pre-block mt-2 mb-0" style="max-height: 10rem;">@_reloadDetail</pre>
                }
            </div>
        }

        <StatusSection RefreshIntervalSeconds="_serviceStatusIntervalSeconds" OnOpenSettings="OpenServiceStatusSettings" />
        <LogsSection RefreshIntervalSeconds="_recentLogsIntervalSeconds" OnOpenSettings="OpenRecentLogsSettings" />

        <SettingsModal IsVisible="_settingsModalOpen" Title="@_settingsModalTitle" SettingsContext="_settingsModalContext" OnClose="CloseSettingsModal" />
    </section>

    <section class="page-section">
        <h2 class="page-section-title">Effective config</h2>
        <p class="text-muted small mb-2">What dnsmasq uses after reading all config files (main + conf-file + conf-dir). Values from a non-managed file are readonly (edit that file to change).</p>
        <ul class="list-unstyled small">
            <EffectiveConfigOptionItem Label="no-hosts" DisplayValue="@(_status.NoHosts ? "Yes (hosts files disabled)" : "No")" Source="@(_status.EffectiveConfigSources?.NoHosts)" />
            <li>
                <strong>addn-hosts:</strong>
                @if (_status.AddnHostsPaths?.Count > 0)
                {
                    var srcList = _status.EffectiveConfigSources?.AddnHostsPaths;
                    if (srcList != null && srcList.Count == _status.AddnHostsPaths.Count)
                    {
                        @foreach (var entry in srcList)
                        {
                            <span class="d-inline-block me-2" title="@(entry.Source?.GetReadOnlyTooltip())">@entry.Path @(entry.Source?.IsReadOnly == true ? " (readonly)" : "")</span>
                        }
                    }
                    else
                    {
                        var deduped = (_status.AddnHostsPaths ?? Array.Empty<string>()).Distinct().ToList();
                        @(deduped.Count == 1 ? deduped[0] : string.Join(", ", deduped))
                    }
                }
                else
                {
                    <span class="text-muted">(none)</span>
                }
            </li>
            @if (_status.SystemHostsPath != null)
            {
                <li><strong>System hosts file (editable):</strong> @_status.SystemHostsPath @(_status.SystemHostsPathExists ? "✓" : "(missing)")</li>
            }
        </ul>
        @if (_status.EffectiveConfig != null)
        {
            var ec = _status.EffectiveConfig;
            var src = _status.EffectiveConfigSources;
            <p class="mb-1 mt-2 text-muted small"><strong>Options</strong> (last wins for single-value; readonly when from a non-managed file):</p>
            <ul class="list-unstyled small ms-2">
                <EffectiveConfigOptionItem Label="expand-hosts" DisplayValue="@(ec.ExpandHosts ? "Yes" : "No")" Source="@(src?.ExpandHosts)" />
                <EffectiveConfigOptionItem Label="bogus-priv" DisplayValue="@(ec.BogusPriv ? "Yes" : "No")" Source="@(src?.BogusPriv)" />
                <EffectiveConfigOptionItem Label="strict-order" DisplayValue="@(ec.StrictOrder ? "Yes" : "No")" Source="@(src?.StrictOrder)" />
                <EffectiveConfigOptionItem Label="no-resolv" DisplayValue="@(ec.NoResolv ? "Yes" : "No")" Source="@(src?.NoResolv)" />
                <EffectiveConfigOptionItem Label="domain-needed" DisplayValue="@(ec.DomainNeeded ? "Yes" : "No")" Source="@(src?.DomainNeeded)" />
                <EffectiveConfigOptionItem Label="dhcp-authoritative" DisplayValue="@(ec.DhcpAuthoritative ? "Yes" : "No")" Source="@(src?.DhcpAuthoritative)" />
                <EffectiveConfigOptionItem Label="no-poll" DisplayValue="@(ec.NoPoll ? "Yes" : "No")" Source="@(src?.NoPoll)" />
                <EffectiveConfigOptionItem Label="bind-interfaces" DisplayValue="@(ec.BindInterfaces ? "Yes" : "No")" Source="@(src?.BindInterfaces)" />
                <EffectiveConfigOptionItem Label="no-negcache" DisplayValue="@(ec.NoNegcache ? "Yes" : "No")" Source="@(src?.NoNegcache)" />
                <EffectiveConfigOptionItem Label="leasefile-ro" DisplayValue="@(ec.LeasefileRo ? "Yes" : "No")" Source="@(src?.LeasefileRo)" />
                <EffectiveConfigOptionItem Label="dhcp-leasefile" DisplayValue="@(ec.DhcpLeaseFilePath ?? "(default)")" Source="@(src?.DhcpLeaseFilePath)" />
                @if (ec.CacheSize.HasValue) { <EffectiveConfigOptionItem Label="cache-size" DisplayValue="@ec.CacheSize.Value.ToString()" Source="@(src?.CacheSize)" /> }
                <EffectiveConfigOptionItem Label="port" DisplayValue="@(ec.Port switch { null => "53 (default)", 0 => "0 (no DNS listener)", _ => ec.Port.Value.ToString() })" Source="@(src?.Port)" />
                @if (ec.LocalTtl.HasValue) { <EffectiveConfigOptionItem Label="local-ttl" DisplayValue="@ec.LocalTtl.Value.ToString()" Source="@(src?.LocalTtl)" /> }
                @if (ec.PidFilePath != null) { <EffectiveConfigOptionItem Label="pid-file" DisplayValue="@ec.PidFilePath" Source="@(src?.PidFilePath)" /> }
                @if (ec.User != null) { <EffectiveConfigOptionItem Label="user" DisplayValue="@ec.User" Source="@(src?.User)" /> }
                @if (ec.Group != null) { <EffectiveConfigOptionItem Label="group" DisplayValue="@ec.Group" Source="@(src?.Group)" /> }
                @if (ec.LogFacility != null) { <EffectiveConfigOptionItem Label="log-facility" DisplayValue="@ec.LogFacility" Source="@(src?.LogFacility)" /> }
                @if (ec.DhcpLeaseMax.HasValue) { <EffectiveConfigOptionItem Label="dhcp-lease-max" DisplayValue="@ec.DhcpLeaseMax.Value.ToString()" Source="@(src?.DhcpLeaseMax)" /> }
                @if (ec.NegTtl.HasValue) { <EffectiveConfigOptionItem Label="neg-ttl" DisplayValue="@ec.NegTtl.Value.ToString()" Source="@(src?.NegTtl)" /> }
                @if (ec.MaxTtl.HasValue) { <EffectiveConfigOptionItem Label="max-ttl" DisplayValue="@ec.MaxTtl.Value.ToString()" Source="@(src?.MaxTtl)" /> }
                @if (ec.MaxCacheTtl.HasValue) { <EffectiveConfigOptionItem Label="max-cache-ttl" DisplayValue="@ec.MaxCacheTtl.Value.ToString()" Source="@(src?.MaxCacheTtl)" /> }
                @if (ec.MinCacheTtl.HasValue) { <EffectiveConfigOptionItem Label="min-cache-ttl" DisplayValue="@ec.MinCacheTtl.Value.ToString()" Source="@(src?.MinCacheTtl)" /> }
                @if (ec.DhcpTtl.HasValue) { <EffectiveConfigOptionItem Label="dhcp-ttl" DisplayValue="@ec.DhcpTtl.Value.ToString()" Source="@(src?.DhcpTtl)" /> }
            </ul>
            <p class="mb-1 mt-2 text-muted small"><strong>Multi-value options</strong> (server/local, address, interface, etc.; each with source when known):</p>
            <ul class="list-unstyled small ms-2">
                @if (ec.ServerLocalValues?.Count > 0) { <EffectiveConfigMultiValueRow Label="server / local" Content="@((MarkupString)RenderMultiValueList(ec.ServerLocalValues, src?.ServerLocalValues))" /> }
                @if (ec.AddressValues?.Count > 0) { <EffectiveConfigMultiValueRow Label="address" Content="@((MarkupString)RenderMultiValueList(ec.AddressValues, src?.AddressValues))" /> }
                @if (ec.Interfaces?.Count > 0) { <EffectiveConfigMultiValueRow Label="interface" Content="@((MarkupString)RenderMultiValueList(ec.Interfaces, src?.Interfaces))" /> }
                @if (ec.ListenAddresses?.Count > 0) { <EffectiveConfigMultiValueRow Label="listen-address" Content="@((MarkupString)RenderMultiValueList(ec.ListenAddresses, src?.ListenAddresses))" /> }
                @if (ec.ExceptInterfaces?.Count > 0) { <EffectiveConfigMultiValueRow Label="except-interface" Content="@((MarkupString)RenderMultiValueList(ec.ExceptInterfaces, src?.ExceptInterfaces))" /> }
                @if (ec.DhcpRanges?.Count > 0) { <EffectiveConfigMultiValueRow Label="dhcp-range" Content="@((MarkupString)RenderMultiValueList(ec.DhcpRanges, src?.DhcpRanges))" /> }
                @if (ec.DhcpHostLines?.Count > 0) { <EffectiveConfigMultiValueRow Label="dhcp-host" Content="@((MarkupString)RenderMultiValueList(ec.DhcpHostLines, src?.DhcpHostLines))" /> }
                @if (ec.DhcpOptionLines?.Count > 0) { <EffectiveConfigMultiValueRow Label="dhcp-option" Content="@((MarkupString)RenderMultiValueList(ec.DhcpOptionLines, src?.DhcpOptionLines))" /> }
                @if (ec.ResolvFiles?.Count > 0) { <EffectiveConfigMultiValueRow Label="resolv-file" Content="@((MarkupString)RenderMultiValueList(ec.ResolvFiles, src?.ResolvFiles))" /> }
            </ul>
        }
    </section>

    <section class="page-section">
        <h2 class="page-section-title">Config</h2>
        <ul class="list-unstyled small">
            <li><strong>Main config:</strong> @(_status.MainConfigPath ?? "—") @(_status.MainConfigPathExists ? "✓" : "(missing)")</li>
            <li><strong>Managed file:</strong> @(_status.ManagedFilePath ?? "—") @(_status.ManagedFilePathExists ? "✓" : "(not created yet)")</li>
        </ul>
        @if (_configSet != null && _configSet.Files?.Count > 0)
        {
            <p class="mb-1 mt-2"><strong>Config set (load order):</strong></p>
            <ul class="list-unstyled small ms-2">
                @foreach (var f in _configSet.Files)
                {
                    <li>
                        @if (f.IsManaged)
                        {
                            <span class="badge bg-primary me-1">managed</span>
                        }
                        else
                        {
                            <span class="badge bg-secondary me-1">@(f.Source.ToString().ToLowerInvariant())</span>
                        }
                        @f.FileName
                        <span class="text-muted">(@f.Path)</span>
                    </li>
                }
            </ul>
        }
    </section>

    <section class="page-section">
        <h2 class="page-section-title">Paths</h2>
        <ul class="list-unstyled small">
            <li>
                <strong>Leases file:</strong> @(_status.LeasesPath ?? "—")
                @if (_status.LeasesPathConfigured)
                {
                    <span>@(_status.LeasesPathExists ? "✓" : "(missing)")</span>
                }
                else
                {
                    <span class="text-muted">(not configured)</span>
                }
            </li>
        </ul>
    </section>
}

@code {
    private string AppTitle => AppOptions!.Value!.EffectiveTitle;
    private int _serviceStatusIntervalSeconds = 15;
    private int _recentLogsIntervalSeconds = 15;
    private bool _settingsModalOpen;
    private string _settingsModalTitle = "Client settings";
    private SettingsModalContext _settingsModalContext = SettingsModalContext.All;
    private ClientSettings _clientSettings = new();

    private DnsmasqServiceStatus? _status;
    private DnsmasqConfigSet? _configSet;
    private string? _error;
    private bool _loading = true;
    private bool _reloading;
    private string? _reloadMessage;
    private string? _reloadDetail;
    private bool _reloadSuccess;
    private readonly CancellationTokenSource _cts = new();

    protected override async Task OnInitializedAsync()
    {
        _loading = true;
        try
        {
            await Task.Delay(1, _cts.Token);
            var token = _cts.Token;
            _clientSettings = await ClientSettingsService.LoadSettingsAsync();
            _serviceStatusIntervalSeconds = Math.Clamp(_clientSettings.ServiceStatusPollingIntervalSeconds, 5, 300);
            _recentLogsIntervalSeconds = Math.Clamp(_clientSettings.RecentLogsPollingIntervalSeconds, 5, 300);
            _status = await StatusClient.GetStatusAsync(token);
            if (_status != null)
            {
                try
                {
                    _configSet = await ConfigSetClient.GetConfigSetAsync(token);
                }
                catch
                {
                    // Config set is optional for Dnsmasq page
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Component disposed or navigated away; ignore
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    private void OpenServiceStatusSettings() => OpenSettingsModal(SettingsModalContext.ServicePolling, "Service status polling");

    private void OpenRecentLogsSettings() => OpenSettingsModal(SettingsModalContext.LogsPolling, "Recent logs polling");

    private static string GetStatusLabel(DnsmasqServiceStatus s)
    {
        return s.DnsmasqStatus switch
        {
            "active" => "Running",
            "inactive" => "Not running",
            "unknown" => "Unknown",
            "notConfigured" => "Status check not configured",
            _ => s.DnsmasqStatus ?? "—"
        };
    }

    private async Task ReloadDnsmasq()
    {
        if (_status == null || !_status.ReloadCommandConfigured || _reloading) return;
        _reloading = true;
        _reloadMessage = null;
        _reloadDetail = null;
        try
        {
            var token = _cts.Token;
            var result = await ReloadClient.ReloadAsync(token);
            if (result.Success)
            {
                _reloadMessage = "Reloaded.";
                _reloadSuccess = true;
            }
            else
            {
                _reloadMessage = "Reload failed" + (result.ExitCode != 0 ? " (exit " + result.ExitCode + ")" : "") + ".";
                _reloadDetail = BuildReloadDetail(result);
                _reloadSuccess = false;
            }
            try
            {
                _status = await StatusClient.GetStatusAsync(token);
            }
            catch
            {
                // Keep _reloadMessage; status will refresh on next page load
            }
        }
        catch (OperationCanceledException) { }
        catch (Exception ex)
        {
            if (_reloadMessage == null) { _reloadMessage = ex.Message; _reloadSuccess = false; }
        }
        finally
        {
            _reloading = false;
        }
    }

    private static string? BuildReloadDetail(ReloadResult r)
    {
        var parts = new List<string>();
        if (!string.IsNullOrEmpty(r.StdOut)) parts.Add("stdout:\n" + r.StdOut);
        if (!string.IsNullOrEmpty(r.StdErr)) parts.Add("stderr:\n" + r.StdErr);
        return parts.Count > 0 ? string.Join("\n\n", parts) : null;
    }

    private void OpenSettingsModal(SettingsModalContext context, string title)
    {
        _settingsModalContext = context;
        _settingsModalTitle = title;
        _settingsModalOpen = true;
    }

    private async Task CloseSettingsModal()
    {
        _settingsModalOpen = false;
        _clientSettings = await ClientSettingsService.LoadSettingsAsync();
        _serviceStatusIntervalSeconds = Math.Clamp(_clientSettings.ServiceStatusPollingIntervalSeconds, 5, 300);
        _recentLogsIntervalSeconds = Math.Clamp(_clientSettings.RecentLogsPollingIntervalSeconds, 5, 300);
        StateHasChanged();
    }

    /// <summary>Renders a multi-value list with per-value source (readonly/editable + tooltip) when EffectiveConfigSources matches; otherwise comma-separated. Returns MarkupString so Blazor renders raw HTML.</summary>
    private static MarkupString RenderMultiValueList(IReadOnlyList<string>? values, IReadOnlyList<ValueWithSource>? sources)
    {
        if (values == null || values.Count == 0)
            return (MarkupString)"(none)";
        if (sources != null && sources.Count == values.Count)
        {
            var parts = sources.Select(e =>
            {
                var src = e.Source;
                var tip = src?.GetReadOnlyTooltip() ?? "";
                var label = src == null ? "?" : (src.IsReadOnly ? "from " + src.FileName + ", readonly" : "editable");
                return $"{System.Net.WebUtility.HtmlEncode(e.Value)} <span class=\"text-muted\" title=\"{System.Net.WebUtility.HtmlEncode(tip)}\">({System.Net.WebUtility.HtmlEncode(label)})</span>";
            });
            return (MarkupString)string.Join(", ", parts);
        }
        return (MarkupString)System.Net.WebUtility.HtmlEncode(string.Join(", ", values));
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
    }
}
